## 프로세스와 스레드
> ### 프로그램, 프로세스, 프로세서란?
- 프로그램     
컴퓨터에서 작업을 위해 실행하는 파일로 운영체제 안에서 파일같은 형태로 저장되어 있다. 쉽게말해 __컴퓨터에서 실행되는 모든 것들을 프로그램이라고 할 수 있다.__ 예를 들어 크롬, 카카오톡, 워드 등을 전부 하나의 프로그램이라고 한다. (일반적으로 애플리케이션이라고 불린다) windows에서 프로그램을 위한 파일은 .exe가 붙는다
<br>
  
- 프로세스        
__운영체제에 의해서 프로그램 파일이 실행되고 있는 상황을 프로세스라고 한다.__ 프로그램이 여러개 실행중인 것은 여러개의 프로세스가 번갈아가면서 수행되고 있는 것이다
<br>

- 프로세서    
__프로세스가 동작될 수 있게 하는 하드웨어로 cpu라고 불린다.__ 즉 cpu에 의해 프로세스가 실행된다    

예를 들어 컴퓨터에 크롬이라는 프로그램이 있다면 크롬이 실행되기 전에는 단순히 프로그램으로 존재한다. 이때 누군가가 크롬을 실행시키게 되면 현재 실행되고 있는 크롬을 프로세스라고 하며 이를 cpu라는 프로세서가 실행시킨다

<br>
<br>

> ### 프로세스의 구조
프로세스는 4가지의 영역으로 나뉜다. 프로세스는 각각 독립된 영역을 할당받게 된다. 

- code(text)영역 : 프로그램 코드가 존재한다
- data 영역 : 전역변수가 존재한다
- heap 영역 : 동적할당된 메모리 공간이 존재한다  
- stack 영역 : 호출된 함수, 지역변수등 임시데이터가 들어간다

![프로세스](https://user-images.githubusercontent.com/64240637/120422516-649c9100-c3a3-11eb-8956-7cdb8fbbe836.png)

프로그램이 실행되면 프로세스의 code영역에 코드들이 전달이 된다. 이후 각각의 영역에 read/write를 실행한다

<br>
<br>

> ### 멀티태스킹의 등장
일반적으로 cpu는 한번에 하나의 프로세스만 관리한다. 과거에는 무언가를 다운로드하는 작업 등을 할때 동시에 다른일을 하는 것이 불가능하였다. 예를 들어 게임을 다운받는 동시에 브라우저로 사이트를 돌아다니는 일이 불가능했다. 이후 컴퓨터가 프로세스 여러개를 함께 돌릴 수 있는 멀티태스킹이 가능해졌다. 멀티태스킹은 한번에 여러개의 프로세스가 동시에 실행되는 것처럼 해준다. 그렇기 때문에 눈으로 봤을때는 동시에 여러개의 프로세스가 실행되는 것처럼 보인다     
즉, cpu가 짧은 시간동안 각각의 프로세스를 순차적으로 번갈아가면서 실행한다. 

<br>

> ### PCB(Process Control Block,프로세스 제어 블록
PCB는 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 커널의 자료구조로, 운영체제가 프로세스를 표현한 것이다. 각 프로세스가 생성될때마다 고유한 PCB가 생성된다.  

- #### PCB의 역할
CPU가 하나의 프로세스에 대한 작업을 처리하다가 운영체제의 명령으로 다른 프로세스를 실행시키기 위해 전환될때 진행하던 작업 내용들을 모두 정리하고 CPU를 반환해야 하는데 이때 앞에서 진행했던 작업들을 모두 저장하지 않으면 다음에 다시 해당 프로세스로 왔을때 어떤 작업을 해야하는지 알 수 없게 된다. 따라서 프로세스는 CPU가 처리하던 작업의 내용들을 자신의 PCB에 저장하고 이후 작업을 수행해야 할때 PCB로부터 해당 정보들을 CPU에 넘겨와 계속했던 작업을 이어서 할 수 있게 된다 

- #### PCB구성 요소
 <img src="https://user-images.githubusercontent.com/64240637/120425649-8d278980-c3a9-11eb-96ca-5d68fb6dad13.jpg" width="250" height="300">     
 - 프로세스 상태 : 준비, 대기, 실행등의 상태    
 - 입출력 상태 정보 : 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등등..   
 - 프로세스 우선순위 : 해당 프로세스의 우선순위 정보     

- #### 프로세스 상태      
![STATE](https://user-images.githubusercontent.com/64240637/120426209-9cf39d80-c3aa-11eb-8ba3-d26687393b72.jpg)     
프로세스의 상태에는 생성, 실행, 준비, 대기, 종료가 있다. 프로세스는 실행되면서 매 순간 상태가 변한다.       

- new : 프로세스가 만들어지는 과정으로 PCB가 만들어진 상태이다      

- ready : 프로세스가 메모리에 적재된 상태로 실행하는데 필요한 자원을 얻은 상태로 Cpu를 할당 받으면 바로 실행이 가능한 상태이다. Cpu가 다른 프로세스를 실행시키고 있는 상황으로 기다리고 있는 상황이다. ready상태에 있는 프로세스는 여러개인데 이중 하나를 고르는 작업을 스케줄링이라고 한다. 
(ready->running)    

- waiting : i/o나 다른 이벤트가 발생하기를 기다리는 것을 나타내는 상태이다. 예를 들어보면 게임을 진행하기 위해 로그인을 진행할때 사용자로부터 아이디와 패스워드 정보를 받기 전까지 Cpu는 해당 작업을 waiting상태로 바꾸고 정보를 받기전까지 다른 프로세스를 가져와 running으로 돌린다. 
(running->waiting, waiting->runnign)     

- running: 프로세스가 cpu를 할당받아 명령어를 수행중인 상태로 실제로 실행중인 프로세스는 매순간 하나뿐이다    
 
- terminated: 프로세스의 실행이 완료되고 할당된 cpu를 반납하는 상태이다       

<br>
<br>

> ### Context Switching
![cs](https://user-images.githubusercontent.com/64240637/120430528-1cd13600-c3b2-11eb-806d-dba82b7cce0f.png)       

- CPU가 한개의 task(프로세스/스레드)를 실행하고 있는 상태에서 interrupt요청에 의해 다른 task로 실행이 전환되는 과정에서 현재 진행하고 있는 task의 상태 정보를 저장하고 다음 진행할 task의 상태 및 레지스터 값들에 대한 정보(context)를 읽어와 새로운 task의 context 정보로 교체하는 과정을 말한다.      
- Cpu가 이전의 프로세스 상태를 pcb에 보관하고 다른 프로세스의 정보를 pcb에서 읽어와 레지스터에 적재하는 과정을 말한다.

- 멀티태스킹을 통해 cpu가 프로세스를 바꿔가며 실행하기 위해서 필요하다        

> 레지스터 : cpu가 요청을 처리하는데 필요한 데이터를 일시적으로 저장하는 기억장치로 cpu는 자체적으로 데이터를 저장할 방법이 없기 때문에 요청한 명령을 처리하기 위한 데이터가 레지스터에 저장되고 레지스터를 통해 요청을 처리한다.

#### context switching이 발생하는 인터럽트
- 입출력 요청이 왔을때
- cpu 사용시간이 만료되었을때 
- 자식 프로세스를 만들때
- 인터럽트 처리를 기다릴때

#### context switching의 단점
context switcing이 자주 일어나면 cpu가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터값을 교체하는 작업을 하는데 이때 Cpu는 아무런 일을 하지 못하므로 자주 발생되면 실행되는 프로세스를 cpu가 처리를 할 수 없게 된다. 즉 cpu의 성능이 떨어지게 된다. 즉 프로세스 개수가 늘어나면 프로세스간에 context switching이 빈번하게 발생될 것이다. 이는 시스템 입장에서는 굉장히 비효율적이다. 이러한 점이 보안되는 것이 __스레드__ 이다   

<br>
<br>

> ### 스레드

#### 오버워치 게임에 예를 들어보자
실제 오버워치라는 게임의 프로그램이 실행될때 동시에 여러가지 프로세스들이 실행되는 경우가 있다. 이렇게 한 번에 여러명에게 사건이 발생하게 되어 여러 프로세스들이 실행될때 cpu는 프로세스들을 왔다갔다하면서 실행시켜준다. 동시에 context switching이 빈번히 일어난다. 이렇게 된다면 cpu의 부담이 늘어나고 비효율적으로 시스템이 관리된다. 이럴때 스레드를 사용하게 된다 
```
1. 총을 맞으면 게이지가 줄어드는 프로세스
2. 일정 게이지가 다 사라지면 몇초 뒤 부활하는 프로세스
3. 치료받으면 일정 게이지가 차는 프로세스
```
<br>

프로세스의 구조와 비교해보자. 프로세스는 모든 영역이 각각 독립되어 존재하기 때문에 하나의 프로그램 내에서 여러개의 실행흐름을 두기 위해서는 프로세스를 새롭게 만들어내야 한다. 따라서 그만큼 Context switching이 발생되기 때문에 프로세스의 증가는 비효율적이다.    
<img src="https://user-images.githubusercontent.com/64240637/120431272-3cb52980-c3b3-11eb-84e2-24470ebd9445.png" width="350" height="300"> 
<br>


스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 하나에 자원을 공유하면서 여러 과정을 동시에 실행시킬수 있는 것을 말한다. 즉 하나의 프로그램에서 둘 이상의 실행 흐름을 만들어 낼 수 있으며 프로세스의 구조에서 스택영역을 제외한 모든 영역을 스레드가 프로세스와 공유한다. 그렇기 때문에 context switching에 걸리는 시간이 프로세스보다 짧다.       
<img src="https://user-images.githubusercontent.com/64240637/120431222-2b6c1d00-c3b3-11eb-8a32-593ea9ec59da.png" width="350" height="300">         
```장점```   
- 프로세스를 생성하여 자원을 할당하는 과정이 줄어들어 자원을 효율적으로 관리할 수 있다    
- 스레드 사이의 작업량이 적어 context switching이 빠르다      
- 프로세스 내의 스택 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다    

```단점```   
- 스레드 하나가 프로세스 내 자원을 망치면 모든 프로세스가 종료된다   
- 자원을 공유하기 때문에 __동기화 문제__ 가 발생한다    


- 멀티코어   
- 멀티 스레딩과 멀티 프로세스    
- 스레드의 동기화 문제   
- 스케줄링     
-  